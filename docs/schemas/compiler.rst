Compiler
=========

The compiler schema is used for compilation of programs, currently we support
single source file compilation. For more details see `Compiler Schema Documentation <https://buildtesters.github.io/schemas/compiler/>`_.


Schema Files
-------------

- `Production Schema <https://raw.githubusercontent.com/buildtesters/buildtest/devel/buildtest/schemas/compiler/compiler-v1.0.schema.json>`_
- `Development Schema <https://buildtesters.github.io/schemas/compiler/compiler-v1.0.schema.json>`_


Compilation Examples
----------------------

In order to use the compiler schema you must set ``type: compiler`` in your
sub-schema. We assume the reader has basic understanding of :ref:`global_schema`
validation.

The **type**, **compiler**, and **executor** are required keys for the schema.

Shown below are 6 test examples performing Hello World compilation with C, C++,
and Fortran using GNU compiler

.. program-output:: cat docgen/compiler_schema/gnu_hello.yml

The tests ``hello_f``, ``hello_c`` and ``hello_cplusplus`` rely on buildtest to
detect compiler wrappers while tests ``cc_example``, ``fc_example``, ``cxx_example``
rely on user to specify compiler wrappers manually.

The ``compiler`` object is start of compilation section, the required
keys are ``source`` and ``name``. The **source** key requires an input program for
compilation, this can be a file relative to buildspec file or an absolute path.
In this example our source examples are in ``src`` directory. The ``name`` field
informs buildtest to auto-detect compiler wrappers (``cc``, ``fc``, ``cxx``).

The compilation pattern buildtest utilizes is the following::

    # C example
    $cc $cppflags $cflags -o <executable> $SOURCE $ldflags

    # Fortran example
    $cxx $cppflags $cxxflags -o <executable> $SOURCE $ldflags

    # Fortran example
    $fc $cppflags $fflags -o <executable> $SOURCE $ldflags

If you specify ``cc``, ``fc`` and ``cxx`` field attributes you are responsible for
selecting the correct compiler wrapper. You can use ``cflags``, ``cxxflags`` and
``fflags`` field to pass compiler options to C, C++ and Fortran compilers.

Shown below is an example build for the buildspec example

.. program-output:: cat docgen/compiler_schema/gnu_hello.txt

The generated test for test name **hello_f** is the following::

    #!/bin/bash
    gfortran -Wall -o hello.f90.exe /global/u1/s/siddiq90/tutorials/examples/serial/src/hello.f90
    ./hello.f90.exe

buildtest will fill in the compilation line based on compilation pattern. buildtest,
will detect the file extensions and perform a lookup to find the programming language,
and finally generate the appropriate C, C++, or Fortran compilation based on language
detected.

buildtest detects the programming language and it finds **.f90** file extension
and infers it must be Fortran program, hence ``gfortran`` was selected. The
executable name is generated by adding ``.exe`` to end of source file name
so we get ``hello.f90.exe``. Finally, we run the executable.

File Extension Language Table
-----------------------------

Shown below is the file extension table for your reference

.. csv-table:: File Extension Language Mapping
    :header: "Language", "File Extension"
    :widths: 30, 80

    "**C**", ".c"
    "**C++**", ".cc .cxx .cpp .c++"
    "**Fortran**", ".f90 .F90 .f95 .f .F .FOR .for .FTN .ftn"

Passing Arguments
-------------------

If you want to pass options to executable command use the ``args`` key. Shown
below is an example test

.. program-output:: cat docgen/compiler_schema/passing_args.yml

The exec_args will pass options to the executable, use this if your binary
requires input arguments. Shown below is a generated test::

    #!/bin/bash
    gcc -Wall -o argc.c.exe /global/u1/s/siddiq90/tutorials/examples/serial/src/argc.c
    ./argc.c.exe 1 2 3


OpenACC Examples
-----------------

Next, we will make use of an OpenACC vector addition example shown below is an
example test

.. program-output:: cat docgen/compiler_schema/vecadd.yml

To compile OpenACC program with gnu compiler we must use ``-fopenacc`` flag, this
program requires linking with math library so we can specify linker flags (ldflags)
using ``ldflags: -lm``.

The output of this test will generate a single line output as follows::

    final result: 1.000000

The ``status`` field with ``regex`` is used for checking output stream using ``stream: stdout``
and ``exp`` key to specify regular expression to use. If we are to build this test,
you will notice the run section will have a Status of ``PASS``

.. program-output:: cat docgen/compiler_schema/vecadd.txt

The regular expression is performed using `re.search <https://docs.python.org/3/library/re.html#re.search>`_, for example if we can change
the ``exp`` field as follows::

    exp: "^final result: 0.99$"

Next if we re-run test we will notice the Status is ``FAIL`` even though we
have a Return Code of **0**::

    +----------------------+
    | Stage: Running Test  |
    +----------------------+

    Name                 Executor             Status               Return Code          Buildspec Path
    ________________________________________________________________________________________________________________________
    vecadd_gnu           local.bash           FAIL                 0                    /global/u1/s/siddiq90/tutorials/examples/openacc/vecadd.yml


In the next example, we extend the previous buildspec test to run at Cori GPU
machine using Slurm scheduler. We use the executor ``slurm.gpu`` where our executor
is defined as follows::

    gpu:
      description: submit jobs to GPU partition
      options: ["-C gpu"]
      cluster: escori

In order to submit job to the Cori GPU cluster we must use ``sbatch -C gpu -M escori`` which
is what ``slurm.gpu`` executor is doing.

In this example we make use of ``module`` field to load modules into the test, for
this test we load the modules ``cuda`` and ``gcc/8.1.1-openacc-gcc-8-branch-20190215``.
This test will launch job via ``srun`` and check job state code is ``COMPLETED``.

::

    version: "1.0"
    buildspecs:
      vecadd_openacc_gnu:
        type: compiler
        description: Vector Addition example with GNU compiler
        executor: slurm.gpu
        sbatch: ["-G 1", "-t 5", "-N 1"]
        module:
          - "module load cuda"
          - "module load gcc/8.1.1-openacc-gcc-8-branch-20190215"
        build:
          name: gnu
          source: src/vecAdd.c
          cflags: -fopenacc
          ldflags: -lm
        run:
          launcher: srun
        status:
          slurm_job_state_codes: COMPLETED

buildtest will generate the following test, buildtest will add the #SBATCH directives
followed by module commands. The executable is run via ``srun`` because we specify the ``launcher`` field. ::

    #!/bin/bash
    #SBATCH -G 1
    #SBATCH -t 5
    #SBATCH -N 1
    module load cuda
    module load gcc/8.1.1-openacc-gcc-8-branch-20190215
    gcc -fopenacc -o vecAdd.c.exe /global/u1/s/siddiq90/buildtest-cori/apps/openacc/src/vecAdd.c -lm
    srun ./vecAdd.c.exe

In this next example, we build same test using `hpcsdk <https://docs.nvidia.com/hpc-sdk/index.html>`_
compiler by NVIDIA that acquired PGI compiler. At cori, we must load ``hpcsdk``
and ``cuda`` module in order to use the hpcsdk compiler. The ``name`` is a
required field however buildtest will ignore since we specify
``cc`` field. NVIDIA changed their compiler names instead of ``pgcc`` we must use
``nvc`` with flag ``-acc`` to offload to GPU. For CoriGPU we must use
``srun`` to acquire GPU access hence ``launcher`` field is set to srun.

::

    version: "1.0"
    buildspecs:
      vecadd_hpcsdk_gnu:
        type: compiler
        description: Vector Addition example with hpcsdk (pgi) compiler
        executor: slurm.gpu
        sbatch: ["-G 1", "-t 5", "-N 1"]
        module:
          - "module load hpcsdk"
          - "module load cuda"
        build:
          name: pgi
          cc: nvc
          source: src/vecAdd.c
          cflags: -acc
          ldflags: -lm
        run:
          launcher: srun


Compiler Schema Examples
-------------------------

The compiler schema examples can be retrieved via ``buildtest schema -n compiler-v1.0.schema.json -e``
which shows a list of valid/invalid buildspec examples using ``type: compiler``.
Each example is validated with schema ``compiler-v1.0.schema.json`` and error
message from invalid examples are also shown in example output.

.. program-output:: cat docgen/schemas/compiler-examples.txt

compiler-v1.0.schema.json
-------------------------

.. program-output:: cat docgen/schemas/compiler-json.txt



